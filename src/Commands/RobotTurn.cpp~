// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotTurn.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

RobotTurn::RobotTurn(double targetAngle, double motorSpeed): frc::Command()
{
	// > 0 = left, < 0 = right
    m_targetAngle = (targetAngle > 0.0) ? Robot::autoTurnAngle[0] : Robot::autoTurnAngle[1];
    m_motorSpeed = motorSpeed;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void RobotTurn::Initialize()
{
	RobotMap::driveTrainWheelEncoder->Reset();
	m_curAngle = 0.0;
	m_curTurnRate = 0.0;
}

// Called repeatedly when this Command is scheduled to run
void RobotTurn::Execute()
{
	m_curAngle = RobotMap::driveTrainWheelEncoder->GetDistance();
	m_curTurnRate = RobotMap::driveTrainWheelEncoder->GetRate();
	float deltaAngle = m_targetAngle - m_curAngle;
	float kFactor = 0.006;
	float speed = deltaAngle * kFactor;
	float sign = (speed < 0.0) ? -1.0 : 1.0;

	if (fabs(speed) > m_motorSpeed)
	{
		speed = m_motorSpeed * sign;
	}
	else if (fabs(speed) < 0.25)
	{
		speed = 0.25 * sign;
	}


//	frc::SmartDashboard::PutNumber("Angle", m_curAngle);

	printf("angle = %4.3f   rate = %4.3f   motor speed = %4.3f \n", m_curAngle, m_curTurnRate, speed);
	Robot::driveTrain->driverRight->Set(speed);
	Robot::driveTrain->driverLeft->Set(speed);
	//Robot::driveTrain->driverRightFront->Set(speed);
	//Robot::driveTrain->driverLeftBack->Set(speed);
}

// Make this return true when this Command no longer needs to run execute()
bool RobotTurn::IsFinished()
{
    bool finished = (fabs(m_curAngle - m_targetAngle) < 0.5) &&
    		fabs(m_curTurnRate) < 10.0;

	return finished;
}

// Called once after isFinished returns true
void RobotTurn::End()
{
	Robot::driveTrain->driverRight->Set(0.0);
	Robot::driveTrain->driverLeft->Set(0.0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RobotTurn::Interrupted() {

}
